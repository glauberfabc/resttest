-- 1. Create profiles table to store public user data
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid NOT NULL PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
  name TEXT,
  role TEXT DEFAULT 'collaborator'::text,
  CONSTRAINT role_check CHECK ((role = ANY (ARRAY['admin'::text, 'collaborator'::text])))
);

COMMENT ON TABLE public.profiles IS 'Stores public-facing profile information for each user.';

-- 2. Function to create a profile for a new user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, name, role)
  VALUES (NEW.id, NEW.raw_user_meta_data->>'name', NEW.raw_user_meta_data->>'role');
  RETURN NEW;
END;
$$;

-- 3. Trigger to call handle_new_user on new user sign-up
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 4. Enable Row Level Security (RLS) for profiles
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles
  FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." ON public.profiles
  FOR UPDATE USING (auth.uid() = id);

-- 5. Create menu_items table
CREATE TABLE IF NOT EXISTS public.menu_items (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid references auth.users(id) on delete cascade not null default auth.uid(),
  name TEXT NOT NULL,
  description TEXT,
  price REAL NOT NULL,
  category TEXT,
  image_url TEXT,
  stock INT,
  low_stock_threshold INT,
  unit TEXT
);
COMMENT ON TABLE public.menu_items IS 'Stores the menu items for the application.';

-- 6. Enable RLS for menu_items
ALTER TABLE public.menu_items ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can manage their own menu items." ON public.menu_items;
CREATE POLICY "Users can manage their own menu items." ON public.menu_items
  FOR ALL USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- 7. Create clients table
CREATE TABLE IF NOT EXISTS public.clients (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid references auth.users(id) on delete cascade not null default auth.uid(),
  name TEXT NOT NULL,
  phone TEXT,
  document TEXT
);
COMMENT ON TABLE public.clients IS 'Stores client information.';

-- 8. Enable RLS for clients
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can manage their own clients." ON public.clients;
CREATE POLICY "Users can manage their own clients." ON public.clients
  FOR ALL USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);


-- 9. Create Storage bucket for product images
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES ('product_images', 'product_images', FALSE, 5242880, ARRAY['image/jpeg', 'image/png', 'image/webp'])
ON CONFLICT (id) DO NOTHING;

-- 10. RLS policies for product_images bucket
-- Allow authenticated users to view their own images
DROP POLICY IF EXISTS "Authenticated users can view their own images" ON storage.objects;
CREATE POLICY "Authenticated users can view their own images" ON storage.objects
  FOR SELECT
  TO authenticated
  USING (bucket_id = 'product_images' AND (storage.foldername(name))[1] = auth.uid()::text);

-- Allow authenticated users to upload images into their own folder
DROP POLICY IF EXISTS "Authenticated users can upload product images" ON storage.objects;
CREATE POLICY "Authenticated users can upload product images" ON storage.objects
  FOR INSERT
  TO authenticated
  WITH CHECK (bucket_id = 'product_images' AND (storage.foldername(name))[1] = auth.uid()::text);

-- Allow authenticated users to update their own images
DROP POLICY IF EXISTS "Authenticated users can update their own images" ON storage.objects;
CREATE POLICY "Authenticated users can update their own images" ON storage.objects
  FOR UPDATE
  TO authenticated
  USING (bucket_id = 'product_images' AND (storage.foldername(name))[1] = auth.uid()::text);

-- Allow authenticated users to delete their own images
DROP POLICY IF EXISTS "Authenticated users can delete their own images" ON storage.objects;
CREATE POLICY "Authenticated users can delete their own images" ON storage.objects
  FOR DELETE
  TO authenticated
  USING (bucket_id = 'product_images' AND (storage.foldername(name))[1] = auth.uid()::text);

-- 11. Function and Event Trigger for PostgREST schema cache reload
CREATE OR REPLACE FUNCTION public.pgrst_watch() RETURNS event_trigger
  LANGUAGE plpgsql
  AS $$
BEGIN
  NOTIFY pgrst, 'reload schema';
END;
$$;

DROP EVENT TRIGGER IF EXISTS pgrst_watch;
CREATE EVENT TRIGGER pgrst_watch ON ddl_command_end
  EXECUTE PROCEDURE public.pgrst_watch();
